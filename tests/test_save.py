import difflib
import fnmatch
import os
import re
import shutil
from types import ModuleType
from typing import List

# BspClasses
from bsp_tool import D3DBsp
from bsp_tool import IdTechBsp
from bsp_tool import QuakeBsp
from bsp_tool import ReMakeQuakeBsp
from bsp_tool import RespawnBsp
from bsp_tool import ValveBsp
# branch scripts
from bsp_tool.branches.id_software import quake
from bsp_tool.branches.id_software import quake2
from bsp_tool.branches.id_software import quake3
from bsp_tool.branches.id_software import remake_quake
from bsp_tool.branches.infinity_ward import modern_warfare
from bsp_tool.branches.respawn import titanfall2
from bsp_tool.branches.strata import strata
from bsp_tool.branches.valve import orange_box

import pytest


# utilities
def map_dirs_to_test(*map_dirs: List[str], ext: str = "*.bsp"):
    """decorator for sourcing test maps"""
    map_names = list()
    map_paths = list()
    for map_dir in map_dirs:
        maps = fnmatch.filter(os.listdir(os.path.join("tests/maps", map_dir)), ext)
        names = [os.path.join(map_dir, m) for m in maps]
        map_names.extend([n.replace("\\", "/") for n in names])
        map_paths.extend([os.path.join("tests/maps", n) for n in names])

    def decorator(test_function):
        """parametrize test for better logging & handle cleanup of files"""

        @pytest.mark.parametrize("map_path", map_paths, ids=map_names)
        def wrapped_test_function(map_path: str):
            shutil.copy(map_path, map_path + ".bak")
            try:
                test_function(map_path)
            except Exception as exc:  # restore the backup when the test fails
                shutil.move(map_path + ".bak", map_path)
                raise exc
            shutil.move(map_path + ".bak", map_path)  # cleanup
        return wrapped_test_function

    return decorator


def xxd(filename: str, width: int = 32) -> str:
    """view a binary file like with a certain hex editor"""
    allowed_chars = re.compile(r"[a-zA-Z0-9/\\]")
    with open(filename, "rb") as binary_file:
        i, bytes_ = 0, binary_file.read(width)
        while bytes_ != b"":
            address = f"0x{i * width:08X}"
            hex_ = " ".join([f"{b:02X}" for b in bytes_])
            if len(hex_) < 3 * width:  # pad last line of hex with spaces
                hex_ += " " * (3 * width - len(hex_))
            ascii_ = "".join([chr(b) if allowed_chars.match(chr(b)) else "." for b in bytes_])
            yield f"{address}:  {hex_}  {ascii_}\n"
            i, bytes_ = binary_file.read(width), i + 1


def save_and_diff_backup(BspClass: object, branch_script: ModuleType, map_path: str) -> str:
    """quick & lazy test; more specific tests should also be performed"""
    bsp = BspClass(branch_script, map_path)
    bsp.save()
    base_name = bsp.filename
    del bsp  # close the file & free data
    # NOTE: the "*.bak" file is generated by the "map_dirs_to_test" decorator
    diff_lines = difflib.unified_diff(xxd(f"{map_path.bak}"), xxd(map_path),
                                      f"{base_name}.bak", base_name)
    return "".join(diff_lines)


# tests
# NOTE: we could generate a bunch of tests w/ more decorators or other magic
# -- but we'll probably have different margins for error
# -- e.g. generously checking diffs, notes in xfail
# TODO: use extensions.diff for a more lenient diff
# -- will need a non-text diff format, probably json/dicts
# -- this will require comparing the backup to the saved map
# NOTE: we don't test the "save_as" method, since "save" wraps it
# -- also means we don't have to worry about name collision
# -- ... tho BspClasses will probably fail to load the ".bak" extension...
@pytest.mark.xfail(raises=NotImplementedError, reason="not implemented yet")
@map_dirs_to_test("Call of Duty 4", "Call of Duty 4/mp", ext="*.d3dbsp")
def test_D3DBsp_modern_warfare(map_path: str):
    diff = save_and_diff_backup(D3DBsp, modern_warfare, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail(raises=NotImplementedError, reason="not implemented yet")
@map_dirs_to_test("Quake 2")
def test_IdTechBsp_quake2(map_path: str):
    diff = save_and_diff_backup(IdTechBsp, quake2, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail(raises=NotImplementedError, reason="not implemented yet")
@map_dirs_to_test("Quake 3 Arena")
def test_IdTechBsp_quake3(map_path: str):
    diff = save_and_diff_backup(IdTechBsp, quake3, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail(raises=NotImplementedError, reason="not implemented yet")
@map_dirs_to_test("ReMakeQuake")
def test_ReMakeQuakeBsp_remake_quake(map_path: str):
    diff = save_and_diff_backup(ReMakeQuakeBsp, remake_quake, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail
@map_dirs_to_test("Titanfall 2")
def test_RespawnBsp_titanfall2(map_path: str):
    diff = save_and_diff_backup(RespawnBsp, titanfall2, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail(raises=NotImplementedError, reason="not implemented yet")
@map_dirs_to_test("Quake")
def test_QuakeBsp_quake(map_path: str):
    diff = save_and_diff_backup(QuakeBsp, quake, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail
@map_dirs_to_test("Team Fortress 2")
def test_ValveBsp_orange_box(map_path: str):
    diff = save_and_diff_backup(ValveBsp, orange_box, map_path)
    assert len(diff) == 0, "not a perfect copy"


@pytest.mark.xfail
@map_dirs_to_test("Momentum Mod")
def test_ValveBsp_strata(map_path: str):
    diff = save_and_diff_backup(ValveBsp, strata, map_path)
    assert len(diff) == 0, "not a perfect copy"
