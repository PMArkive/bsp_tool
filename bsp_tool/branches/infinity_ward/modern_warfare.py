# https://wiki.zeroy.com/index.php?title=Call_of_Duty_4:_d3dbsp
import enum
import struct

from ...utils import editor
from ...utils import physics
from ...utils import vector
from .. import base
from .. import shared
from ..id_software import quake
from ..id_software import quake3
from . import call_of_duty2


FILE_MAGIC = b"IBSP"

BSP_VERSION = 22

GAME_PATHS = {"Call of Duty 4: Modern Warfare": "Call of Duty 4"}

GAME_VERSIONS = {GAME_NAME: BSP_VERSION for GAME_NAME in GAME_PATHS}


# NOTE: lumps are given ids and headers reference these ids in order
class LUMP(enum.Enum):
    TEXTURES = 0x00
    LIGHTMAPS = 0x01
    LIGHT_GRID_POINTS = 0x02
    LIGHT_GRID_COLOURS = 0x03
    PLANES = 0x04
    BRUSH_SIDES = 0x05
    UNKNOWN_6 = 0x06
    UNKNOWN_7 = 0x07
    BRUSHES = 0x08
    LAYERED_TRIANGLE_SOUPS = 0x09
    LAYERED_VERTICES = 0x0A
    LAYERED_INDICES = 0x0B
    PORTAL_VERTICES = 0x13
    LAYERED_AABB_TREE = 0x18
    CELLS = 0x19
    PORTALS = 0x1A
    NODES = 0x1B
    LEAVES = 0x1C
    LEAF_BRUSHES = 0x1D
    LEAF_FACES = 0x1E
    COLLISION_VERTICES = 0x1F
    COLLISION_TRIANGLES = 0x20
    COLLISION_EDGE_WALK = 0x21
    COLLISION_BORDERS = 0x22
    COLLISION_PARTS = 0x23
    COLLISION_AABBS = 0x24
    MODELS = 0x25
    ENTITIES = 0x27
    PATHS = 0x28
    REFLECTION_PROBES = 0x29  # textures? pretty huge
    LAYERED_DATA = 0x2A
    PRIMARY_LIGHTS = 0x2B
    LIGHT_GRID_HEADER = 0x2C
    LIGHT_GRID_ROWS = 0x2D
    SIMPLE_TRIANGLE_SOUPS = 0x2F
    SIMPLE_VERTICES = 0x30
    SIMPLE_INDICES = 0x31
    SIMPLE_AABB_TREE = 0x33
    LIGHT_REGIONS = 0x34
    LIGHT_REGION_HULLS = 0x35
    LIGHT_REGION_AXES = 0x36


class LumpHeader(base.MappedArray):
    id: int  # see LUMP
    length: int
    # generated by D3DBsp._preload
    offset: int  # calculated from the sum of preceding lump's lengths (+ padding)
    name: str  # LUMP(id).name
    _mapping = ["id", "length"]
    _format = "2I"
    _classes = {"id": LUMP}


# Known lump changes from Call of Duty 2 -> Call of Duty 4:
# New:
#   LIGHT_GRID_HASHES -> LIGHT_GRID_POINTS
#   LIGHT_GRID_VALUES -> LIGHT_GRID_COLOURS
#   UNKNOWN_6
#   UNKNOWN_7
#   TRIANGLE_SOUPS -> LAYERED_TRIANGLE_SOUPS & SIMPLE_TRIANGLE_SOUPS
#   VERTICES -> LAYERED_VERTICES & SIMPLE_VERTICES
#   TRIANGLES -> LAYERED_INDICES & SIMPLE_INDICES ?
#   AABB_TREE -> LAYERED_AABB_TREE & SIMPLE_AABB_TREE
#   COLLISION_EDGES -> COLLISION_EDGE_WALK ?
#   REFLECTION_PROBES
#   LAYERED_DATA
#   PRIMARY_LIGHTS
#   LIGHT_GRID_HEADER
#   LIGHT_GRID_ROWS
#   LIGHT_REGIONS
#   LIGHT_REGION_HULLS
#   LIGHT_REGION_AXES
# Deprecated:
#   CULL_GROUPS
#   CULL_GROUP_INDICES
# NOTE: func_cull_group is still present in CoD4Radiant


# a rough map of the relationships between lumps:

#      /-> Brush
# Model -> Mesh        /-> Vertex
#      \-> TriangleSoup -> Triangle -?> Vertex


# classes for lumps, in alphabetical order:
class Brush(base.Struct):  # LUMP 0x08
    num_sides: int
    unknown: int
    __slots__ = ["num_sides", "unknown"]
    _format = "2H"


class BrushSide(base.Struct):  # LUMP 0x05
    distance: int  # axial: Plane distance (float), non-axial: Plane index (uint32_t)
    texture: int  # index into Textures
    __slots__ = ["plane", "texture"]
    _format = "2I"


# {"LUMP_NAME": LumpClass}
BASIC_LUMP_CLASSES = {
    "LAYERED_INDICES":   shared.UnsignedShorts,
    "LIGHT_GRID_POINTS": shared.UnsignedInts,
    "LIGHT_REGIONS":     shared.UnsignedBytes,
    "SIMPLE_INDICES":    shared.UnsignedShorts}

LUMP_CLASSES = {
    "BRUSHES":             Brush,
    "BRUSH_SIDES":         BrushSide,
    "COLLISION_TRIANGLES": call_of_duty2.Triangle,
    "COLLISION_VERTICES":  quake.Vertex,
    "LAYERED_VERTICES":    call_of_duty2.Vertex,
    "PLANES":              quake3.Plane,
    "TEXTURES":            quake3.Texture,
    "SIMPLE_VERTICES":     call_of_duty2.Vertex}

SPECIAL_LUMP_CLASSES = {"ENTITIES": shared.Entities}


def brush(bsp, brush_index) -> editor.Brush:
    # NOTE: generates a generic TextureVector
    first_side = sum(b.num_sides for b in bsp.BRUSHES[:brush_index])
    brush = bsp.BRUSHES[brush_index]
    assert brush.num_sides >= 6
    sides = bsp.BRUSH_SIDES[first_side:first_side + brush.num_sides]

    def int_as_float(x: int) -> float:
        return struct.unpack("f", x.to_bytes(4, "little"))[0]

    def texture_name(side: BrushSide) -> str:
        return bsp.TEXTURES[side.texture].name.decode().split("\x00")[0]

    out = list()  # axial: -X +X -Y +Y -Z +Z; non-axial: w/e
    for (axis, sign), side in zip([(a, s) for a in "xyz" for s in (-1, 1)], sides[:6]):
        plane = physics.Plane(vector.vec3(**{axis: sign}), int_as_float(side.plane) * sign)
        out.append(editor.BrushSide(plane, texture_name(side)))
    out.extend([editor.BrushSide(bsp.PLANES[side.plane], texture_name(side)) for side in sides[6:]])
    return editor.Brush(out)


# NOTE: no mins & maxs in worldspawn?
methods = [brush]
methods = {m.__name__: m for m in methods}
