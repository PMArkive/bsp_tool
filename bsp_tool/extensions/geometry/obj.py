from __future__ import annotations
import collections
from typing import Dict, Generator, List

from ...utils import geometry


class Obj:
    """Y+ forward; Z+ up"""
    groups: Dict[str, Dict[str, geometry.Model]]
    # ^ {"group_name": {"model_name": model}}

    @classmethod
    def from_groups(cls, *unnamed_groups, **groups) -> Obj:
        index = 0
        for group in unnamed_groups:
            group_name = f"group_{index:03X}"
            while group_name in unnamed_groups:
                index += 1
                group_name = f"group_{index:03X}"
            groups[group_name] = group
        out = cls()
        out.groups = groups
        return out

    @classmethod
    def from_models(cls, *unnamed_models, **models) -> Obj:
        index = 0
        for model in unnamed_models:
            model_name = f"model_{index:03X}"
            while model_name in unnamed_models:
                index += 1
                model_name = f"model_{index:03X}"
            models[model_name] = model
        return cls.from_groups(**{"group_000": models})

    def __repr__(self) -> str:
        num_models = sum(len(ms) for ms in self.groups.values())
        descriptor = f"{len(self.groups)} groups {num_models} model"
        return f"<{self.__class__.__name__} {descriptor} @ 0x{id(self):016X}>"

    def lines(self) -> Generator[str, None, None]:
        yield "# generated by bsp_tool.extensions.geometry"

        def indices(polygon: geometry.Polygon) -> List[int]:
            """rexx magic obj indexing; works for Blender, might break elsewhere"""
            # NOTE: inverts winding order; which is desired
            return range(-1, -(len(polygon.vertices) + 1), -1)

        # TODO: make sure None group is first
        for group_name, models in self.groups.items():
            yield f"g {group_name}"
            for model_name, model in models.items():
                yield f"o {model_name}"
                polygons = collections.defaultdict(list)
                # ^ {Material: [Polygon]}
                for mesh in model.meshes:
                    polygons[mesh.material].extend(mesh.polygons)
                for material in polygons:
                    yield f"usemtl {material.name}"
                    # TODO: generate .mtl files & include w/ "mtllib {material.name}.mtl"
                    for polygon in polygons[material]:
                        vertices = [*map(model.apply_transforms, polygon.vertices)]
                        # NOTE: only the first uv can be saved
                        if all(len(v.uv) > 0 for v in vertices):
                            for v in vertices:
                                yield f"v {v.position.x} {v.position.y} {v.position.z}"
                                yield f"vn {v.normal.x} {v.normal.y} {v.normal.z}"
                                yield f"vt {v.uv[0].x} {v.uv[0].y}"
                            yield "f " + " ".join([
                                f"{i}/{i}/{i}" for i in indices(polygon)])
                        else:  # no uv
                            for v in vertices:
                                yield f"v {v.position.x} {v.position.y} {v.position.z}"
                                yield f"vn {v.normal.x} {v.normal.y} {v.normal.z}"
                            yield "f " + " ".join([
                                f"{i}//{i}" for i in indices(polygon)])

    def save_as(self, filename: str):
        # TODO: assert filename is a valid path
        with open(filename, "w") as obj_file:
            obj_file.write("\n".join(self.lines()))

    # TODO: @classmethod from_file(cls, filename) -> Obj:
